==Compiling Validator==

Nothing fancy. Just compile in yavl.cpp and all the cpp files of
yaml-cpp with your program. I believe that libraries should pollute
your build process as little as possible (thankfully, so does
yaml-cpp).

Here is how you would compile the example checker program,
example-code/checker.cpp. YAML_CPP_DIR is where you
untarred the yaml-cpp source and YAVL_CPP_DIR is where
you untarred the yavl-cpp source.

{{{
g++ -I$YAML_CPP_DIR/include -I$YAVL_CPP_DIR/src \
  $YAML_CPP_DIR/src/*.cpp \
  $YAVL_CPP_DIR/src/yavl.cpp \
  $YAVL_CPP_DIR/example-code/checker.cpp -o checker
}}}

And run it like this:

{{{
checker $YAVL_CPP_DIR/example-specs/gr3.yaml $YAVL_CPP_DIR/example-specs/y0.gr3.yaml
}}}

==Compiling Toolchain==

First you need to generate the toolchain binary 'tc':

{{{
g++ -I$YAML_CPP_DIR/include -I$YAVL_CPP_DIR/src \
  $YAML_CPP_DIR/src/*.cpp \
  $YAVL_CPP_DIR/src/yatc.cpp \
  $YAVL_CPP_DIR/example-code/tc.cpp -o tc
}}}

Then you need to run it on a treespec file. It will generate a .cpp file and a .h
file. The .h contains an autogenerated struct hierarchy to store a typed
version of the YAML file in memory. The .cpp file contains the code to do the
actual reading.

And run it like this (in succeeding steps, I'll assume
this was run in YAVL_CPP_DIR):

{{{
tc $YAVL_CPP_DIR/example-specs/gr4.yaml gr4
}}}

will generate 'gr4.cpp' and 'gr4.h'.

To build a program that actually uses these files to read and write YAML files
corresponding to the treespec of gr4.yaml, do something similar to what the
example program 'yatc-client.cpp' does. Build it like this:

{{{
g++ -I$YAML_CPP_DIR/include -I$YAVL_CPP_DIR/src \
  $YAML_CPP_DIR/src/*.cpp \
  $YAVL_CPP_DIR/src/gr4.cpp \
  $YAVL_CPP_DIR/example-code/yatc-client.cpp -o yatc-client
}}}

And run the generated program like this:

{{{
yatc-client $YAVL_CPP_DIR/example-specs/y0.gr4.yaml
}}}

It will read in the file into the class hierarchy and then dump a YAML file
generated from the in-memory class hierarchy. You'll see that the list will
be in multiline format in the emitted YAML, whereas it is in inline format
in the original.
